#pragma once

#include <vector>
#include <cmath>
#include <algorithm>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

class WorldObliteratorEngine {
public:
    WorldObliteratorEngine() {}
    ~WorldObliteratorEngine() {}

    void prepare(double sampleRate);

    void process(float** buffer, int numSamples);

    void setInputIntake(float value) { inputIntake = value; }
    void setOutputDoomsday(float value) { outputDoomsday = value; }
    void setImpactDistortion(float value) { impactDistortion = value; }
    void setTargetFrequency(float value) { targetFreq = value; }
    void setResonance(float value) { resonance = value; }
    void setMixBlend(float value) { mixBlend = value; }
    
    void setPunch(bool state) { punchActive = state; }
    void setAutoGain(bool state) { autoGainActive = state; }

private:
    struct SVF {
        float g, k, ic1eq, ic2eq;
        void setup(float cutoff, float Q, float sr) {
            float f = std::tan(M_PI * cutoff / sr);
            g = f / (1.0f + f);
            k = 1.0f / Q;
            reset();
        }
        void reset() { ic1eq = ic2eq = 0; }
        float processLP(float v0) {
            float v3 = v0 - ic2eq;
            float v1 = g * (v3 - k * ic1eq) / (1.0f + g * (g + k));
            float v2 = ic2eq + g * v1;
            ic1eq = 2.0f * v1 - ic1eq;
            ic2eq = 2.0f * v2 - ic2eq;
            return v2;
        }
        float processHP(float v0) {
            float v3 = v0 - ic2eq;
            float v1 = g * (v3 - k * ic1eq) / (1.0f + g * (g + k));
            float v2 = ic2eq + g * v1;
            ic1eq = 2.0f * v1 - ic1eq;
            ic2eq = 2.0f * v2 - ic2eq;
            return v0 - k * v1 - v2;
        }
    };

    struct LR4 {
        SVF stage1, stage2;
        void setup(float cutoff, float sr) {
            stage1.setup(cutoff, 0.7071f, sr);
            stage2.setup(cutoff, 0.7071f, sr);
        }
        float processLP(float in) { return stage2.processLP(stage1.processLP(in)); }
        float processHP(float in) { return stage2.processHP(stage1.processHP(in)); }
    };

    float applyAsymmetricDistortion(float in, float drive) {
        float x = in * drive;
        if (x >= 0.0f) return std::tanh(x);
        return std::tanh(x * 1.2f) / 1.2f;
    }

    double sampleRate = 44100.0;
    
    float inputIntake = 0.75f;
    float outputDoomsday = 0.25f;
    float impactDistortion = 0.0f;
    float targetFreq = 80.0f;
    float resonance = 1.0f;
    float mixBlend = 1.0f;
    bool punchActive = false;
    bool autoGainActive = false;

    SVF mainLP[2], dcBlock[2], antiFizz[2];
    LR4 crossLow[2], crossHigh[2];

    float limiterGain = 1.0f;
};
